<!doctype html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Photon File Converter</title>
	<script type="text/javascript" src="libs/bit-array.js"></script>
	<script type="text/javascript" src="libs/UPNG.js"></script>
	<script type="text/javascript" src="libs/Pako.js"></script>

	<script type="text/javascript" src="thumbnailSource\bigThumb.js"></script>
	<script type="text/javascript" src="thumbnailSource\smallThumb.js"></script>
	<script type="text/javascript" src="thumbnailSource\SThumb.js"></script>

	<style>
		#attribution p{
			margin: 12px;
    	bottom: -5px;
		}

		#attribution p:first-child{
			left:12px;
		}

		#attribution p:last-child{
			right: 12px;
			text-align: right;
		}

		#attribution a{
			text-decoration: none;
			color: #87a6ff;
		}

		.numInput{
			width:70px;
		}

	</style>
</head>

<body>
	<div style="color:#000000ff" id="inputs">
		<input type="file" id="files" name="files[]" accept=".png" onchange="onFileSelected(event)"/> </br> </br>

		<!-- <input class="numInput" type="number" max="20" min="0" id="input_zDist" value="5" onfocusout="checkInput(0)"> Z-lift distance in mm</input></br>
		<input class="numInput" type="number" max="8" min="0" id="input_zSpeed" value="5" step="0.5" onfocusout="checkInput(1)"> Z-lift speed in mm/s</input></br>
		<input class="numInput" type="number" max="8" min="0" id="input_zRetract" value="5" step="0.5" onfocusout="checkInput(2)"> z retract speed in mm/s</input></br></br> -->

		<select id="output_fileFormat">
			<option value="pws">.pws</option>
		  <option value="ps">.photons</option>
		  <option value="p">.photon</option>
		</select> output file format</br></br>

		<!-- <input type="checkbox" id="overwriteValues" onclick="toggleOverwrite()"> overwrite any settings?</input></br>
		<div id="overwriteInputs" style="display:none;">
			<div style="padding-top:10px; padding-bottom:7px;">	overwrite ot your own risk. </div>
			<input class="numInput" type="number" id="input_layerHeight" max="2" min="0.01" value="0.05" step="0.01" onfocusout="checkInput(3)"> Layer height in mm</input></br>
			<input class="numInput" type="number" id="input_exposure" value="8" step="0.5" onfocusout="checkInput(4)"> curing time in seconds</input></br>
			<input class="numInput" type="number" id="input_offTime" value="4.5" onfocusout="checkInput(5)"> off time in seconds</input></br>
			<input class="numInput" type="number" id="input_bottomExposure" value="60" onfocusout="checkInput(6)"> bottom exposure time</input></br>
			<input class="numInput" type="number" id="input_numBottomLayers" value="8" step="1" onfocusout="checkInput(7)"> number of bottom layers</input></br></br>
			<input type="text" id="input_newName"> new filename</input>
		</div></br> -->

		<button onclick="submit()" id="submit_Button" style="display:none;">convert file</button>
		<script>

			let fname = "";

			/*function toggleOverwrite(){
				updateSubmitButton();
				document.getElementById("overwriteInputs").style = "display:" + (document.getElementById("overwriteValues").checked ? "block" : "none");
			}*/

			/*function checkInput(src){
				switch(src){
					case 0:
						el = document.getElementById("input_zDist");
						if(el.value > 20) el.value = 20;
						if(el.value < 0) el.value = 0;
					break;
					case 1: case 2:
						el = src == 1 ? document.getElementById("input_zSpeed") : document.getElementById("input_zRetract");
						if(el.value > 8) el.value = 8;
						if(el.value < 0) el.value = 0;
					break;

					case 3:
						el = document.getElementById("input_layerHeight");
						if(el.value > 2) el.value = 2;
						if(el.value < 0.00) el.value = 0.00;
					break;
				}
			}*/

			/*function updateSubmitButton(){
				if(isPhotonS)	document.getElementById("submit_Button").innerHTML = "update file";
				else {
					if(document.getElementById("overwriteValues").checked) document.getElementById("submit_Button").innerHTML = "convert and update file";
					else document.getElementById("submit_Button").innerHTML = "convert file";
				}

				document.getElementById("submit_Button").style = "display:block;";
			}*/

			/*function updateInputs(){
				let h = photonFile.header;
				document.getElementById("input_newName").value = fname.slice(0, fname.lastIndexOf("."));

				document.getElementById("input_layerHeight").value = h.layerThickness;
				document.getElementById("input_exposure").value = h.exposureTime;
				document.getElementById("input_offTime").value = h.offTime;
				document.getElementById("input_bottomExposure").value = h.bottomExposureTime;
				document.getElementById("input_numBottomLayers").value = h.bottomLayers;

				if(isPhotonS){
					document.getElementById("input_zDist").value = h.zLift;
					document.getElementById("input_zSpeed").value = h.zRetract;
					document.getElementById("input_zRetract").value = h.zSpeed;
				}
			}*/

			function submit(){
			}

			/*function convertLayersToBitArrays(){
					let layers = [];
					let numPixelsInLayer = 2560 * 1440;
					for(i = 0; i < photonFile.header.layers; i++){

							let currLayerArray = new BitArray(numPixelsInLayer);
							let layer = photonFile.layers[i];
							let o = layer.dataOffset;
							let pixelPos = 0;
							while(pixelPos < numPixelsInLayer){
									let run = photonFile.fileDataView.getInt8(o++);
									let col = false
									if (run < 0){run = 128 + run; col = true;}
									for(j = 0; j < run; j++){
										currLayerArray.set(pixelPos+j, col);
									}
									pixelPos+=run;
							}
							layers.push(currLayerArray);
					}
					return layers;
			}*/

			/*function bitArraysToRuns(inLayers){
				let layers = [];
				for(i = 0; i < inLayers.length; i++){
					let inLayer = inLayers[i];
					let layer = []
					let currRun = 0;
					let currRunCol = inLayer.get(0);
					for(pixelPos = 0; pixelPos < (2560 * 1440); pixelPos++){
						if(inLayer.get(pixelPos) == currRunCol && currRun < 125){
							currRun++;
						}else{
							layer.push(currRun | (currRunCol ? 0x80 : 0));
							currRunCol = inLayer.get(pixelPos);
							currRun = 1;
						}
					}
					if(currRun > 0){
						layer.push(currRun | (currRunCol ? 0x80 : 0));
					}
					layers.push(layer);
				}
				return layers;
			}*/

			function saveByteArray(array, name, ending){
				// supply ending as a string with the ., so ".photons" or ".pws" etc.
				link = document.createElement( 'a' );
				link.style.display = 'none';
				document.body.appendChild( link );
				blob = new Blob( [ array ], { type: 'application/octet-binary' } );
				link.href = URL.createObjectURL( blob );
				link.download =  name + ending;
				link.click();
			}

			/*function convertToRuns(idx) {

				let long_colors = [];
				let long_lengths = [];
				let layer = photonFile.layers[idx];
				let o = isPhotonS ? layer.layerDataPosition : layer.dataOffset;
				let posPixels = 0;
				numWhitePxInLayer = 0;

				firstPix = photonFile.fileDataView.getInt8(o);
				currCol = firstPix < 0 ? 1 : 0;
				currRun = 0;

				while (posPixels < photonFile.header.resX * photonFile.header.resY) {

					let b = photonFile.fileDataView.getInt8(o++);
					let pixelCount = b;
					let oldCol = currCol;

					if (pixelCount < 0)
					{
						pixelCount = 128 + pixelCount;
						currCol = 1;
						numWhitePxInLayer += pixelCount;
					} else {
						currCol = 0;
					}

					if(currCol == oldCol) currRun += pixelCount;
					else {
						long_colors.push(oldCol);
						long_lengths.push(currRun);
						currRun = pixelCount;
					}

					posPixels += pixelCount;

				}

				long_colors.push(currCol);
				long_lengths.push(currRun);

				let short_colors = [];
				let short_lengths = [];

				for(i = 0; i < long_lengths.length; i++){
					col = long_colors[i];
					len = long_lengths[i];
					numRuns = Math.floor(len/128);
					remainder = len%128;
					for(j = 0; j < numRuns; j++){
						short_colors.push(col);
						short_lengths.push(128);
					}
					if(remainder>0){
						short_colors.push(col);
						short_lengths.push(remainder);
					}
				}

				let return_layer = {
					colors: short_colors,
					lengths: short_lengths,
					whitePx: numWhitePxInLayer
				};

				return return_layer;

			}*/

			// var sublayer = 0;

			function loadPhotonFile(d) {
				readPngLayer(d);
			}

			/*
			function checkArraysForCoverage(inList){ // checks if all pixels in an aa layer are correct. a pixel is invalid , if it's supposed to be  a 1/4th exposure, but only the 2nd, 3rd and 4th layers are set
				for(var i = 0; i < 3686400; i++){
					hasBeen0 = false;
					for(var j = 0; j < 8; j++){
							colPixel = inList[j].get(i);
							if(colPixel == 0) hasBeen0 = true;
							//if(hasBeen0 && colPixel == 1) console.log("pixel at " + i + " has an error");
					}
				}
				console.log("file has been checked");
			}

			function saveSublayer(startPos, numBytes, d){ // saves numBytes of a binary file d starting at start pos
				newFileArrayBuffer = new ArrayBuffer(numBytes);
				newFile = new DataView(newFileArrayBuffer);
				for(var i = 0; i < numBytes; i++){
						newFile.setUint8(i, d.getUint8(startPos+i));
				}
				saveByteArray(newFileArrayBuffer, "SLayer" + sublayer, ".sl");
			}

			function savePngLayers(inList){ // save bit array as png, supports AA as grayscale
				console.log("running");
				//for(var i = 0; i < 8; i++){
				AAMultiple = Math.min(Math.round(255 / inList.length),255);

				layerPixels = new Uint8Array(3686400*4);
				for(var j = 0; j < 3686400; j++){
					pixVal = 0
					hasBeen0 = false;
					pixError = false;
					for(var i = 0; i < inList.length; i++){
							subpixCol = inList[i].get(j);
							pixVal += subpixCol
							if(subpixCol == 0) hasBeen0 = true;
							if(hasBeen0 && subpixCol == 1) pixError = true;
					}
					pixCol = Math.min(pixVal*AAMultiple,255);
					layerPixels[j*4] = 255;
					layerPixels[(j*4)+3] = 255;
					if(!pixError){
						layerPixels[j*4] = pixCol;
						layerPixels[(j*4)+1] = pixCol;
						layerPixels[(j*4)+2] = pixCol;
					}
				}
				png = UPNG.encode([layerPixels.buffer], 1440, 2560, 0);
				saveByteArray(png, "Layer" + i, ".png");
				//}
			}

			function readPngLayer(layer){ // read png and save as encoded pws/photon layer only 1bit grayscale.
				var pngImport = UPNG.decode(layer);
				var pixelData = new DataView(UPNG.toRGBA8(pngImport)[0]);
				var outRunsArray = [];
				currentRun = 1;
				currentCol = Math.round(pixelData.getUint8(0)/255);
				for(var i = 1; i < 3686400; i++){
						col = Math.round(pixelData.getUint8(i*4)/255);
						if(currentCol == col){
							if(currentRun == 125){
								outRunsArray.push(currentRun | (col<<7));
								currentRun=0;
							}
							currentRun++;
						}else{
							outRunsArray.push(currentRun | (currentCol<<7));
							currentCol = col;
							currentRun = 1;
						}
				}

				if(currentRun > 0){
						outRun = (currentCol<<7) | currentRun;
						outRunsArray.push(outRun);
				}

				newFileArrayBuffer = new ArrayBuffer(outRunsArray.length);
				newFile = new DataView(newFileArrayBuffer);
				for(var i = 0; i < outRunsArray.length; i++){
						newFile.setUint8(i, outRunsArray[i]);
				}
				saveByteArray(newFileArrayBuffer, "layer", ".sl");
			}
			*/

			function onFileSelected(evt) {
				let files = evt.target.files;

				if (files.length == 1) {
					fname = evt.target.files[0].name;
					isPhotonS = fname.slice((fname.lastIndexOf(".") - 1 >>> 0) + 2) == "photons";

					let r = new FileReader();

					r.onload = function(event) {
						let d = new DataView(event.target.result);
						loadPhotonFile(event.target.result);
						//renderThumbnail(loadImage(photonFile.header.smallThumbOffset, d, isPhotonS), document.getElementById('thumb-small'));
					};

					r.readAsArrayBuffer(files[0]);
					updateSubmitButton();
				}

			}

		</script>

	</div>
</body>
</html>
